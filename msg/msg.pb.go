// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: msg.proto

package msg

import (
	encoding_binary "encoding/binary"
	"errors"
	io "io"
	math_bits "math/bits"
)

type InitAuthCompleted_Statuses int32

const (
	OK    InitAuthCompleted_Statuses = 0
	FAIL  InitAuthCompleted_Statuses = 1
	RETRY InitAuthCompleted_Statuses = 2
)

var InitAuthCompleted_Statuses_name = map[int32]string{
	0: "OK",
	1: "FAIL",
	2: "RETRY",
}

var InitAuthCompleted_Statuses_value = map[string]int32{
	"OK":    0,
	"FAIL":  1,
	"RETRY": 2,
}

// InitConnect
// @Function
// @Return: InitResponse
type InitConnect struct {
	ClientNonce uint64 `protobuf:"fixed64,1,opt,name=ClientNonce,proto3" json:"ClientNonce,omitempty"`
}

// InitCompleteAuth
// @Function
// @Return: InitAuthCompleted
type InitCompleteAuth struct {
	ClientNonce      uint64 `protobuf:"fixed64,1,opt,name=ClientNonce,proto3" json:"ClientNonce,omitempty"`
	ServerNonce      uint64 `protobuf:"fixed64,2,opt,name=ServerNonce,proto3" json:"ServerNonce,omitempty"`
	ClientDHPubKey   []byte `protobuf:"bytes,5,opt,name=ClientDHPubKey,proto3" json:"ClientDHPubKey,omitempty"`
	P                uint64 `protobuf:"fixed64,6,opt,name=P,proto3" json:"P,omitempty"`
	Q                uint64 `protobuf:"fixed64,7,opt,name=Q,proto3" json:"Q,omitempty"`
	EncryptedPayload []byte `protobuf:"bytes,8,opt,name=EncryptedPayload,proto3" json:"EncryptedPayload,omitempty"`
}

// InitResponse
type InitResponse struct {
	ClientNonce          uint64 `protobuf:"fixed64,1,opt,name=ClientNonce,proto3" json:"ClientNonce,omitempty"`
	ServerNonce          uint64 `protobuf:"fixed64,2,opt,name=ServerNonce,proto3" json:"ServerNonce,omitempty"`
	RSAPubKeyFingerPrint uint64 `protobuf:"fixed64,3,opt,name=RSAPubKeyFingerPrint,proto3" json:"RSAPubKeyFingerPrint,omitempty"`
	DHGroupFingerPrint   uint64 `protobuf:"fixed64,4,opt,name=DHGroupFingerPrint,proto3" json:"DHGroupFingerPrint,omitempty"`
	PQ                   uint64 `protobuf:"fixed64,5,opt,name=PQ,proto3" json:"PQ,omitempty"`
	ServerTimestamp      int64  `protobuf:"varint,6,opt,name=ServerTimestamp,proto3" json:"ServerTimestamp,omitempty"`
}

// InitCompleteAuthInternal
type InitCompleteAuthInternal struct {
	SecretNonce []byte `protobuf:"bytes,1,opt,name=SecretNonce,proto3" json:"SecretNonce,omitempty"`
}

// InitAuthCompleted
type InitAuthCompleted struct {
	ClientNonce    uint64                     `protobuf:"fixed64,1,opt,name=ClientNonce,proto3" json:"ClientNonce,omitempty"`
	ServerNonce    uint64                     `protobuf:"fixed64,2,opt,name=ServerNonce,proto3" json:"ServerNonce,omitempty"`
	Status         InitAuthCompleted_Statuses `protobuf:"varint,3,opt,name=Status,proto3,enum=msg.InitAuthCompleted_Statuses" json:"Status,omitempty"`
	SecretHash     uint64                     `protobuf:"fixed64,4,opt,name=SecretHash,proto3" json:"SecretHash,omitempty"`
	ServerDHPubKey []byte                     `protobuf:"bytes,5,opt,name=ServerDHPubKey,proto3" json:"ServerDHPubKey,omitempty"`
}

var fileDescriptor_c06e4cca6c2cc899 = []byte{
	// 475 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xbd, 0x8e, 0xd3, 0x4c,
	0x14, 0xf5, 0x38, 0x1b, 0x7f, 0xd9, 0xbb, 0x51, 0x3e, 0x33, 0xa2, 0xb0, 0x28, 0x86, 0xc8, 0x05,
	0x44, 0x48, 0x38, 0xd2, 0x6e, 0x41, 0x01, 0x4d, 0xd8, 0x1f, 0x12, 0x2d, 0x02, 0x67, 0xb2, 0x0d,
	0x74, 0x8e, 0x33, 0x38, 0x96, 0xe2, 0x19, 0xcb, 0x33, 0x46, 0x4a, 0xc9, 0x1b, 0xf0, 0x54, 0x28,
	0x65, 0xca, 0x2d, 0x49, 0xd2, 0x50, 0xf2, 0x08, 0xc8, 0x33, 0xbb, 0x92, 0xc9, 0xae, 0x44, 0xb3,
	0x9d, 0xef, 0xb9, 0xe7, 0xdc, 0x9f, 0xe3, 0x3b, 0x70, 0x98, 0xc9, 0x24, 0xc8, 0x0b, 0xa1, 0x04,
	0x6e, 0x64, 0x32, 0x79, 0xf2, 0x32, 0x49, 0xd5, 0xbc, 0x9c, 0x06, 0xb1, 0xc8, 0xfa, 0x89, 0x48,
	0x44, 0x5f, 0xe7, 0xa6, 0xe5, 0x17, 0x1d, 0xe9, 0x40, 0x7f, 0x19, 0x8d, 0xdf, 0x87, 0xa3, 0x11,
	0x4f, 0xd5, 0xa9, 0xe0, 0x9c, 0xc5, 0x0a, 0x77, 0xe1, 0xe8, 0x74, 0x91, 0x32, 0xae, 0x3e, 0x08,
	0x1e, 0x33, 0x0f, 0x75, 0x51, 0xcf, 0xa1, 0x75, 0xc8, 0xff, 0x81, 0xc0, 0x35, 0x8a, 0x2c, 0x5f,
	0x30, 0xc5, 0x06, 0xa5, 0x9a, 0xff, 0x5b, 0x56, 0x31, 0x26, 0xac, 0xf8, 0xca, 0x0a, 0xc3, 0xb0,
	0x0d, 0xa3, 0x06, 0xe1, 0x67, 0xd0, 0x31, 0x82, 0xb3, 0x61, 0x58, 0x4e, 0x2f, 0xd9, 0xd2, 0x6b,
	0x76, 0x51, 0xaf, 0x4d, 0xf7, 0x50, 0xdc, 0x06, 0x14, 0x7a, 0x8e, 0xd6, 0xa3, 0xb0, 0x8a, 0xc6,
	0xde, 0x7f, 0x26, 0x1a, 0xe3, 0x17, 0xe0, 0x9e, 0xf3, 0xb8, 0x58, 0xe6, 0x8a, 0xcd, 0xc2, 0x68,
	0xb9, 0x10, 0xd1, 0xcc, 0x6b, 0xe9, 0x2a, 0x77, 0x70, 0xff, 0x37, 0x82, 0x76, 0xb5, 0x08, 0x65,
	0x32, 0x17, 0x5c, 0xb2, 0x07, 0x59, 0xe2, 0x18, 0x1e, 0xd3, 0xc9, 0xc0, 0x4c, 0x7a, 0x91, 0xf2,
	0x84, 0x15, 0x61, 0x91, 0x72, 0xe5, 0x35, 0x34, 0xf5, 0xde, 0x1c, 0x0e, 0x00, 0x9f, 0x0d, 0xdf,
	0x15, 0xa2, 0xcc, 0xeb, 0x8a, 0x03, 0xad, 0xb8, 0x27, 0x83, 0x3b, 0x60, 0x87, 0x63, 0x6d, 0x8e,
	0x43, 0xed, 0x70, 0x8c, 0x7b, 0xf0, 0xbf, 0x19, 0xe1, 0x2a, 0xcd, 0x98, 0x54, 0x51, 0x96, 0x6b,
	0x7b, 0x1a, 0x74, 0x1f, 0xf6, 0xdf, 0x80, 0xb7, 0xff, 0xeb, 0x46, 0x5c, 0xb1, 0x82, 0x47, 0x0b,
	0xb3, 0x5b, 0x5c, 0xb0, 0xda, 0xf6, 0x6d, 0x5a, 0x87, 0xfc, 0x6f, 0x36, 0x3c, 0xaa, 0xe4, 0x95,
	0xec, 0xb6, 0xc4, 0xec, 0x41, 0x5c, 0x7b, 0x05, 0xce, 0x44, 0x45, 0xaa, 0x94, 0xda, 0xa7, 0xce,
	0xf1, 0xd3, 0xa0, 0x3a, 0xea, 0x3b, 0xbd, 0x02, 0x43, 0x62, 0x92, 0xde, 0xd0, 0x31, 0x01, 0x30,
	0x13, 0x0e, 0x23, 0x39, 0xbf, 0xb1, 0xac, 0x86, 0x54, 0x37, 0x65, 0xfa, 0xec, 0xdf, 0xd4, 0xdf,
	0xa8, 0xff, 0x1c, 0x5a, 0xb7, 0xb5, 0xb1, 0x03, 0xf6, 0xc7, 0x4b, 0xd7, 0xc2, 0x2d, 0x38, 0xb8,
	0x18, 0x8c, 0xde, 0xbb, 0x08, 0x1f, 0x42, 0x93, 0x9e, 0x5f, 0xd1, 0x4f, 0xae, 0xfd, 0xf6, 0x64,
	0xb5, 0x21, 0xd6, 0x7a, 0x43, 0xac, 0xeb, 0x0d, 0xb1, 0x56, 0x5b, 0x82, 0xd6, 0x5b, 0x82, 0x7e,
	0x6e, 0x09, 0xfa, 0xb5, 0x25, 0xd6, 0xf7, 0x1d, 0xb1, 0x56, 0x3b, 0x62, 0xad, 0x77, 0xc4, 0xba,
	0xde, 0x11, 0xeb, 0x73, 0x33, 0x78, 0x9d, 0xc9, 0x64, 0xea, 0xe8, 0xa7, 0x76, 0xf2, 0x27, 0x00,
	0x00, 0xff, 0xff, 0xf8, 0xb6, 0x71, 0xa1, 0xab, 0x03, 0x00, 0x00,
}

func (m *InitConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitConnect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitConnect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClientNonce != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ClientNonce))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *InitCompleteAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitCompleteAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitCompleteAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedPayload) > 0 {
		i -= len(m.EncryptedPayload)
		copy(dAtA[i:], m.EncryptedPayload)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.EncryptedPayload)))
		i--
		dAtA[i] = 0x42
	}
	if m.Q != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Q))
		i--
		dAtA[i] = 0x39
	}
	if m.P != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.P))
		i--
		dAtA[i] = 0x31
	}
	if len(m.ClientDHPubKey) > 0 {
		i -= len(m.ClientDHPubKey)
		copy(dAtA[i:], m.ClientDHPubKey)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ClientDHPubKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ServerNonce != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ServerNonce))
		i--
		dAtA[i] = 0x11
	}
	if m.ClientNonce != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ClientNonce))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *InitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServerTimestamp != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ServerTimestamp))
		i--
		dAtA[i] = 0x30
	}
	if m.PQ != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PQ))
		i--
		dAtA[i] = 0x29
	}
	if m.DHGroupFingerPrint != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.DHGroupFingerPrint))
		i--
		dAtA[i] = 0x21
	}
	if m.RSAPubKeyFingerPrint != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RSAPubKeyFingerPrint))
		i--
		dAtA[i] = 0x19
	}
	if m.ServerNonce != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ServerNonce))
		i--
		dAtA[i] = 0x11
	}
	if m.ClientNonce != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ClientNonce))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *InitCompleteAuthInternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitCompleteAuthInternal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitCompleteAuthInternal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SecretNonce) > 0 {
		i -= len(m.SecretNonce)
		copy(dAtA[i:], m.SecretNonce)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SecretNonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InitAuthCompleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitAuthCompleted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitAuthCompleted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServerDHPubKey) > 0 {
		i -= len(m.ServerDHPubKey)
		copy(dAtA[i:], m.ServerDHPubKey)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ServerDHPubKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SecretHash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SecretHash))
		i--
		dAtA[i] = 0x21
	}
	if m.Status != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.ServerNonce != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ServerNonce))
		i--
		dAtA[i] = 0x11
	}
	if m.ClientNonce != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ClientNonce))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func encodeVarintMsg(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsg(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InitConnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientNonce != 0 {
		n += 9
	}
	return n
}

func (m *InitCompleteAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientNonce != 0 {
		n += 9
	}
	if m.ServerNonce != 0 {
		n += 9
	}
	l = len(m.ClientDHPubKey)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.P != 0 {
		n += 9
	}
	if m.Q != 0 {
		n += 9
	}
	l = len(m.EncryptedPayload)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *InitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientNonce != 0 {
		n += 9
	}
	if m.ServerNonce != 0 {
		n += 9
	}
	if m.RSAPubKeyFingerPrint != 0 {
		n += 9
	}
	if m.DHGroupFingerPrint != 0 {
		n += 9
	}
	if m.PQ != 0 {
		n += 9
	}
	if m.ServerTimestamp != 0 {
		n += 1 + sovMsg(uint64(m.ServerTimestamp))
	}
	return n
}

func (m *InitCompleteAuthInternal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SecretNonce)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func (m *InitAuthCompleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientNonce != 0 {
		n += 9
	}
	if m.ServerNonce != 0 {
		n += 9
	}
	if m.Status != 0 {
		n += 1 + sovMsg(uint64(m.Status))
	}
	if m.SecretHash != 0 {
		n += 9
	}
	l = len(m.ServerDHPubKey)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	return n
}

func sovMsg(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsg(x uint64) (n int) {
	return sovMsg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InitConnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.New("proto: InitConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.New("proto: InitConnect: illegal tag %d (wire type %d)")
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field ClientNonce")
			}
			m.ClientNonce = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientNonce = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitCompleteAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.New("proto: InitCompleteAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.New("proto: InitCompleteAuth: illegal tag %d (wire type %d)")
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field ClientNonce")
			}
			m.ClientNonce = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientNonce = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field ServerNonce")
			}
			m.ServerNonce = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNonce = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 2 {
				return errors.New("proto: wrong wireType = %d for field ClientDHPubKey")
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientDHPubKey = append(m.ClientDHPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ClientDHPubKey == nil {
				m.ClientDHPubKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field P")
			}
			m.P = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.P = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 7:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field Q")
			}
			m.Q = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Q = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 8:
			if wireType != 2 {
				return errors.New("proto: wrong wireType = %d for field EncryptedPayload")
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedPayload = append(m.EncryptedPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedPayload == nil {
				m.EncryptedPayload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.New("proto: InitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.New("proto: InitResponse: illegal tag %d (wire type %d)")
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field ClientNonce")
			}
			m.ClientNonce = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientNonce = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field ServerNonce")
			}
			m.ServerNonce = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNonce = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field RSAPubKeyFingerPrint")
			}
			m.RSAPubKeyFingerPrint = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RSAPubKeyFingerPrint = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field DHGroupFingerPrint")
			}
			m.DHGroupFingerPrint = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.DHGroupFingerPrint = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field PQ")
			}
			m.PQ = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.PQ = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 6:
			if wireType != 0 {
				return errors.New("proto: wrong wireType = %d for field ServerTimestamp")
			}
			m.ServerTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitCompleteAuthInternal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.New("proto: InitCompleteAuthInternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.New("proto: InitCompleteAuthInternal: illegal tag %d (wire type %d)")
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.New("proto: wrong wireType = %d for field SecretNonce")
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretNonce = append(m.SecretNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.SecretNonce == nil {
				m.SecretNonce = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitAuthCompleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.New("proto: InitAuthCompleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.New("proto: InitAuthCompleted: illegal tag %d (wire type %d)")
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field ClientNonce")
			}
			m.ClientNonce = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientNonce = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field ServerNonce")
			}
			m.ServerNonce = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNonce = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 0 {
				return errors.New("proto: wrong wireType = %d for field Status")
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InitAuthCompleted_Statuses(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return errors.New("proto: wrong wireType = %d for field SecretHash")
			}
			m.SecretHash = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretHash = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 2 {
				return errors.New("proto: wrong wireType = %d for field ServerDHPubKey")
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerDHPubKey = append(m.ServerDHPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerDHPubKey == nil {
				m.ServerDHPubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsg
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMsg
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, errors.New("proto: illegal wireType %d")
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMsg
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMsg        = errors.New("proto: negative length found during unmarshaling")
	ErrIntOverflowMsg          = errors.New("proto: integer overflow")
	ErrUnexpectedEndOfGroupMsg = errors.New("proto: unexpected end of group")
)
